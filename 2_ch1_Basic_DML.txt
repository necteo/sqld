SQL
    1. SQL의 개념 및 유형
            => 관계형 데이터베이스에서 데이터를 정의, 조작, 제어하기 위해 사용하는 언어
                = 데이터 정의어(DDL)
                    - 데이터 스키마를 설정하거나 수정하는 작업을 의미함
                    - CREATE, ALTER, DROP, RENAME, TRUNCATE
                = 데이터 조작어(DML)
                    - 데이터베이스 내의 인스턴스(레코드)를 다루는 작업을 의미함
                    - SELECT, INSERT, UPDATE, DELETE
                = 데이터 제어어(DCL)
                    - 사용자 계정을 생성하거나 권한을 부여하는 등 데이터베이스의 접근 및 사용을 관리하는 작업을 의미함
                    - GRANT, REVOKE
                = 트랜잭션 제어어
                    - 데이터의 일관성과 무결성을 보장하기 위해 작업을 트랜잭션 단위로 묶어서 관리하는 작업을 의미함
                    - COMMIT, ROLLBACK
            => SQL은 DDL, DML, DCL, TCL이 결합되어 SQL의 전체적인 문법을 형성
            => 영어에서 동명사, 전치사, to 부정사 등 다양한 문법 요소가 결합되어 하나의 언어 체계를 이루는 것과 유사한 원리
    2. SQL 기본 작성 규칙
        1) 문장 종료 : SQL 문장은 ;으로 종료한다
        2) 대소문자 구분 : 명령어, 객체명, 변수명은 대소문자를 구분하지 않는다 => 데이터 값은 대소문자를 구분한다
        3) 문자열 및 날짜 값 : 문자열(String)과 날짜(Date) 값은 작은따옴표('')를 사용한다
        4) 공백과 줄 바꿈 : 단어와 단어 사이는 공백 또는 줄 바꿈으로 구분한다
        5) 주석문 : 코드의 실행에는 영향을 미치지 않지만, 가독성을 높이고 내용을 설명하기 위해 사용된다
            => 단일행 주석 : 주석 내용 앞에 -- 입력
            => 다중행 주석 : 주석 내용의 시작에 /*, 끝에 */ 입력

===========================================================================================================================================================================================================

SELECT 문
    1. SELECT 문 : 데이터베이스 테이블에서 원하는 데이터를 조회할 때 사용하는 명령어
        => SELECT * => SQL에서 테이블의 모든 칼럼을 조회할 때 사용 => 예) SELECT * FROM player;
        => 특정 칼럼 조회 => player 테이블에서 player_id, player_name, team_id, position 칼럼만을 조회하고자 한다면 => 예) SELECT player_id, player_name, team_id, position FROM player;
    2. ALL과 DISTINCT
        1) ALL
            = SELECT와 칼럼 사이에 ALL을 명시하면 중복 데이터를 포함하여 모든 데이터를 출력
            = ALL은 기본값으로, 별도로 명시하지 않아도 SELECT만 사용하면 SELECT ALL로 처리
            => 예) SELECT ALL position FROM player; => SELECT position FROM player;
        2) DISTINCT
            = 중복 데이터를 제거하고, 고유한 데이터만 출력한다(중복 데이터를 1건으로 출력)
            = DISTINCT는 SELECT 키워드 바로 뒤, 첫 번째 칼럼 앞에 위치해야 한다
            = DISTINCT는 단순히 하나의 칼럼만 중복 체크를 하는 것이 아니라, 지정된 여러 칼럼의 조합을 기준으로 중복을 판단한다
            = DISTINCT는 NULL 값을 하나의 고유한 값으로 간주 => position 칼럼에 여러 개의 NULL 값이 있더라도 하나의 NULL 값만 출력된다
            => 예) SELECT DISTINCT POSITION FROM PLAYERS;
    3. 각종 SELECT 문법
        1) FROM 절
            = FROM 절은 데이터를 조회할 테이블을 지정하는 구문 => SELECT~ FROM~;와 같이 SELECT 문에서 반드시 필요한 요소
            => 예) SELECT 5+4 FROM PLAYER => 가능 / SELECT 5+4 => 에러 발생
        2) DUAL 테이블
            = 앞선 예에서 SELECT 5+4 FROM PLAYER;를 실행하면, 테이블의 행 수만큼 5+4의 결과가 반복 출력된다 => PLAYER 테이블의 데이터를 사용하지는 않지만 테이블의 행 수만큼 반복 수행
            => 단순히 5+4의 값을 확인하고 싶지만 FROM 절에 사용할 적절한 테이블이 없다 => DUAL 테이블 활용
            => 오라클에 내장된 테이블 => 하나의 행과 하나의 칼럼 => 칼럼의 이름은 DUMMY, 값은 x
            => 테스트나 임시 연산을 위해 만들어짐 => 산술 연산의 FROM 절에 사용 시 1개의 결과만을 출력 => DUAL 테이블은 1개의 행만 가지고 있다
        3) 별칭(Alias)
            => SELECT 문에서 별칭은 테이블이나 칼럼에 임시 이름을 붙여서 결과를 더 이해하기 쉽게 만들거나 간결하게 표현할 때 사용 => 조회 결과에 별칭을 부여하여 칼럼명을 변경
            => 칼럼명과 별칭 사이에 AS 키워드를 사용 => 예) SELECT 5+4 (AS) RESULT FROM DUAL;
            => 별칭에 공백이나 특수문자가 포함될 경우 "" 사용 => 예) SELECT 5+4 AS "결과 확인" FROM DUAL;

===========================================================================================================================================================================================================

ORDER BY 절
    1. 개념
        => 기본적으로 관계형 데이터베이스의 레코드는 저장 순서와 관계없이 출력
        => 데이터를 특정 순서대로 출력해야 하는 경우
        => 결과 데이터를 원하는 순서대로 정렬하여 출력
    2. 작성
        => SQL 문장 마지막에 위치한다
        => 오름차순은 ASC / 생략 가능 (기본값)
        => 내림차순은 DESC / 생략 불가
        => 예) SELECT PLAYER_NAME, HEIGHT FROM PLAYER ORDER BY HEIGHT ASC; / ~ FROM PLAYER ORDER BY 2;(칼럼2)
    예) SELECT PLAYER_NAME, HEIGHT FROM PLAYER ORDER BY HEIGHT DESC, PLAYER_NAME ASC;

===========================================================================================================================================================================================================

WHERE 절
    1. 개념
        => 특정 조건을 만족하는 데이터만을 선택하기 위해 사용
        => SELECT로 데이터를 조회할 때 조건을 지정하여 필요한 데이터만 한정적으로 추출
        => SELECT ~ FROM ~ WHERE
        => 예) SELECT PLAYER_ID, POSITION FROM PLAYER WHERE POSITION = 'GK';
    2. 연산자의 종류
        = 산술 연산자 : + , - , * , /
        = 비교 연산자 : = , <> , > , >= , < , <=
        = 논리 연산자 : AND , OR , NOT
        = SQL 연산자 : || , BETWEEN a AND b , (NOT) IN(list) , LIKE '비교 문자열' , IS (NOT) NULL
    3. 연산자의 우선순위
        ()
        * /
        + -
        ||
        = <> > < >= <=
        BETWEEN , LIKE , IN , IS NULL
        NOT
        AND
        OR
    산술 연산자 : NUMBER와 DATE 자료형에 적용할 수 있는 연산자
        => 예) SELECT PLAYER_NAME, ((HEIGHT-100) * 0.9 - WEIGHT) AS "적정 체중" FROM PLAYER WHERE ((HEIGHT-100) * 0.9 -WEIGHT) > 0;
        => NULL 값에 산술 연산을 적용하면 모두 NULL 값이 조회
    비교 연산자 : SQL에서 데이터를 비교하기 위해 사용 => 모든 자료형(숫자, 날짜, 문자열 등)에 적용 가능
        = 문자열 데이터의 경우 사전 순
        = NULL 값의 처리
            => NULL 값은 비교 연산자로 평가할 수 없음 => IS NULL / IS NOT NULL과 같은 별도의 연산자 사용
            => 예) SELECT * FROM PLAYER WHERE NATION IS NULL;
    논리 연산자 : NOT > AND > OR
    SQL 연산자
        1. 합성(연결) 연산자
            = CONCAT 함수 => CONCAT(str1, str2) => str1, str2 문자열 연결 => SELECT PLAYER_NAME, CONCAT(HEIGHT, 'Cm') AS "선수 신장" FROM PLAYER;
            = || 연산자 => str1 || str2 => str1과 str2를 바로 연결 => SELECT PLALYER_NAME, HEIGHT || 'Cm' AS "선수 신장" FROM PLAYER;
                => 여러 개의 문자열 연속적으로 연결 가능
            => 예) SELECT PLAYER_NAME || ' 선수: ' || HEIGHT || 'Cm' AS "선수 신장" FROM PLAYER;
        2. BETWEEN 연산자 => SELECT PLAYER_NAME 선수이름, POTISION 포지션, HEIGHT 키 FROM PLAYER WHERE HEIGHT (NOT) BETWEEN 170 AND 180;
        3. IN 연산자 => SELECT PLAYER_NAME, TEAM_ID FROM PLAYER WHERE TEAM_ID IN ('K04', 'K06);
        => 예) SELECT PLAYER_NAME 선수이름, TEAM_ID, POSITION FROM PLAYER WHERE (TEAM_ID, POSITION) IN (('K04', 'GK'), ('K06', 'MF'));
               SELECT PLAYER_NAME 선수이름, TEAM_ID, POSITION FROM PLAYER WHERE (TEAM_ID, POSITION) NOT IN (('K04', 'GK'), ('K06', 'MF'));
               SELECT PLAYER_NAME 선수이름, TEAM_ID, POSITION FROM PLAYER WHERE TEAM_ID IS NULL OR POSITION IS NULL;
        4. LIKE 연산자 => % : 임의의 문자 N개, _ : 임의의 문자 1개
            => 예) SELECT PLAYER_NAME FROM PLAYER WHERE PLAYER_NAME LIKE '김%' ('김_'); 
    출력 개수 지정(ROWNUM)
        => 특정 순서에 따라 레코드에 고유 번호를 부여하는 Pseudo Column => 1부터 시작
        => 시스템이 자동 관리
        => 채번 및 출력 개수를 지정할 때 사용
        => 예) SELECT PLAYER_NAME, ROWNUM FROM PLAYER; (ROWNUM은 존재하지 않지만 명시적으로 지정하여 사용 가능)
        => 한 행만 => SELECT PLAYER_NAME FROM PLAYER WHERE ROWNUM = 1;
        => 여러 행 => SELECT PLAYER_NAME FROM PLAYER WHERE ROWNUM < 4;

===========================================================================================================================================================================================================

레코드 삽입(INSERT), 삭제(DELETE), 갱신(UPDATE)
    레코드 삽입(INSERT)
        => 테이블에 새로운 데이터를 추가할 때 사용
        => 특정 칼럼 / 전체 칼럼의 값을 지정하여 입력
        => INSERT ALL => 한번에 여러 데이터 입력
        => 유의사항 : 문자 또는 날짜 값은 '' 사용 / 숫자 데이터는 그냥 사용
        => 예) INSERT INTO PLAYER (PLAYER_ID, PLAYER_NAME, TEAM_ID, BIRTH_DATE) VALUES ('2999001', '손흥민', 'K07', '1999-01-01'); => 정의되지 않은 칼럼은 NULL 입력
        => 예) INSERT INTO PLAYER VALUES ('2999002', '이강인', 'K07', '', '', '2010', 'MF', '10', NULL, NULL, NULL, NULL, NULL);
        => 예) INSERT ALL INTO STADIUM(STADIUM_ID, STADIUM_NAME) VALUES ('TP1', '임시경기장1') INTO STADIUM(STADIUM_ID, STADIUM_NAME) VALUES ('TP2', '임시경기장2') SELECT * FROM DUAL;
    레코드 삭제(DELETE)
        => 테이블에 존재하는 데이터를 삭제할 때 사용
        => DELETE 테이블명; / DELETE FROM 테이블명;
        => 예) DELETE FROM STADIUM WHERE STADIUM_ID = 'TP1';
    레코드 갱신(UPDATE)
        => 테이블에 존재하는 데이터를 수정할 때 사용
        => UPDATE 테이블명 SET 칼럼명 = 새로운 값;
        => 예) UPDATE STADIUM SET STADIUM_NAME = '우리경기장' WHERE STADIUM_ID = 'TP2';
