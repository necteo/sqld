데이터 모델링 : 현실 데이터를 단순하고 이해하기 쉽게 표현
            -> 복잡한 현실세계를 추상화, 단순화, 명확화하여 중요한 요소와 관계를 일정한 표기법에 의해 표현하는 것
            
            특징)
                1. 추상화 : 현실의 복잡한 데이터를 주요한 정보만 남기고 표현하는 과정 , 모형화
                           불필요한 정보는 제외하고, 필요한 데이터와 그 관계만 집중적으로 표현함
                2. 단순화 : 복잡한 데이터를 이해하기 쉬운 구조로 표현하는 과정
                3. 명확화 : 데이터의 구조와 관계를 명확하게 표현아형 오해의 여지를 없애는 과정
            -> 올바르게 수행되지 않는 경우 : 중복성 -> 같은 데이터가 여러 곳에 저장되어 관리가 비효율적이고 불일치가 발생할 수 있음
                                         비유연성 -> 데이터 모델링이 변화에 대응하지 못해 시스템 확장이나 수정이 어려움
                                         비일관성 -> 동일한 데이터가 다르게 저장되거나 표현되어 데이터의 신뢰성이 저하됨
            
            관점)
                1. 데이터 관점(What) : 데이터 관점에서 모델링 수행
                                      저장하고 관리해야 하는 데이터 자체제 초점을 맞춘다 -> 데이터와 데이터 간의 관계, 업무와 데이터간 관계
                                      예) 수강 신청 -> 아이디, 학번, 비밀번호 등
                2. 프로세스 관점(How) : 데이터를 어떻게 처리할지에 초점을 맞춘다 -> 업무의 흐름과 절차 중심
                                      예) 수강 신청 -> 아이디/비밀번호 입력 -> 수강 과목 선택 -> 수강 신청서 작성 -> 관리자 승인 -> 학생 수강 정보 저장
                3. 데이터와 프로세스의 상관 관점(Interaction) : 데이터와 프로세스가 서로 밀접하게 연결되어 있다는 점을 강조
                                                            데이터와 프로세스는 상호 의존적인 관계
데이터 모델링의 3단계
            1. 개념적 데이터 모델링 : 현실 세계의 데이터를 추상화하여 개념적 구조를 설계한다
            2. 논리적 데이터 모델링 : 개념적 구조를 바탕으로 논리적 단계와 데이터 속성을 정의하여 논리적 구조를 설계한다
            3. 물리적 데이터 모델링 : 논리적 구조를 기반으로 컴퓨터에서 데이터를 저장할 구체적인 방식, 즉 물리적 구조를 설계한다

            물리적 구조(저장 데이터베이스) + 논리적 구조 => 물리(컴퓨터) 세계
            개념적 구조 + 논리적 구조 => 개념 세계
                        = 개념 세계 : 개념적 구조와 논리적 구조를 포함하면, 사람이 이해할 수 있는 데이터의 논리적 흐름과 관계를 설명
                        = 물리 세계 : 논리적 구조와 물리적 구조를 포함하면, 컴퓨터가 데이터를 저장하고 처리하는 구체적인 방식을 다룬다
            
                                    학계                                    산업계
            개요        개념적/논리적 모델링을 명확히 구분            명확히 구분하지 않음
                        논리적 모델링에서 테이블 도출                물리적 모델링에서 테이블 도출
            개념적            ERD 도출                             핵심 엔터티/관계/속성 중심 ERD 도출
            모델링      관계가 자체 속성을 가질 수 있음              관계가 자체 속성을 가질 수 없음
            
            논리적            테이블 도출                           훨씬 구체적인 수준의 ERD 도출
            모델링           PK, FK 지정                           시스템으로 구축하고자 하는 업무에 대해 식별자, 속성, 관계 등을 명시
                        정규화 및 반정규화 수행                      M:N 관계 해소 => 여러 개의 1:N으로 분해
            
            물리적       실제 DBMS에 맞는 테이블 구축                테이블 도출(PK, FK, 칼럼 정의)
            모델링       데이터 타입 정의, 인덱스 설계, 뷰 설계       정규화 및 반정규화
                                                                   데이터 타입 정의, 인덱스 설계, 뷰 설계

데이터 독립성 : 데이터와 응용 프로그램을 분리하여 설계 및 관리의 효율성을 높이는 것을 목표 => 파일 시스템
            = 파일 시스템 구조와 문제점
                        1) 데이터 중복 관리
                        2) 데이터 불일치 문제
            데이터베이스 시스템 => 데이터의 중복 관리 제거, 일관성 유지, 효율적인 데이터 공유
                        1) 데이터의 통합 관리 => 하나의 데이터베이스에서 통합 관리
                        2) 데이터 공유와 일관성 유지 : 데이터베이스에 저장된 데이터를 여러 프로그램이 공유하여 사용

데이터베이스의 3단계 구조
            = 외부 스키마 : 응용 프로그램이나 사용자 관점에서 데이터를 표현
                        예) '내 급여는 얼마인가?', '부서 간 평균 급여의 차이는?', '입사한 지 10년이 넘은 사원의 리스트는?'
            = 개념 스키마 : 외부 스키마에서 요구된 모든 데이터를 통합하여 설계한 데이터의 논리적 구조 => 데이터 간의 관계
                        예) 데이터 A,B,C / B,C,D / D,E,F => 통합 A,B,C,D,E,F
            = 내부 스키마 : 개념 스키마를 물리적으로 저장 => 데이터가 실제로 저장되는 방식(파일, 인덱스 등)과 최적화된 데이터베이스 구조

데이터의 종속성과 독립성
            = 데이터 종속성 : 응용 프로그램과 데이터 간의 상호 의존 관계 => 주로 파일 시스템에서 발생하는 문제
                        데이터 파일의 구조가 변경되면 해당 응용 프로그램도 이에 따라 수정
            = 데이터 독립성 : 데이터 구조의 변경이 응용 프로그램에 영향을 주지 않는 특성 => 논리적 독립성, 물리적 독립성
                        = 논리적 독립성 : 논리적 사상(외부적/개념적 사상)을 통해 논리적 독립성이 보장
                                    개념 스키마(논리적 구조)가 변경되어도 외부 스키마가 영향을 받지 않음
                        = 물리적 독립성 : 물리적 사상(개념적/내부적 사상)을 통해 물리적 독립성이 보장됨
                                    내부 스키마가 변경되어도 개념 스키마가 영향을 받지 않음
            데이터 독립성이 유지되지 않는 경우
            = 데이터 중복성과 복잡도가 증가 => 동일한 데이터가 여러 프로그램과 파일에서 중복으로 관리 => 데이터 불일치 문제 => 수정이 복잡
            = 요구사항에 대응하는 난이도가 증가 => 유지보수 비용 상승 => 데이터 구조 변경시 모든 프로그램 수정 => 시스템의 유연성과 효율성 저하

데이터 모델링의 요소
            데이터 모델링의 3가지 구성 요소
                        = 엔터티(Entity) : 업무에서 관리해야 할 개체 또는 대상(Thing)
                                    예) 고객, 상품, 주문 등
                        = 속성(Attribute) : 엔터티가 가지는 특성이나 정보
                                    예) 고객의 이름, 연락처, 주소 등
                        = 관계(Relationship) : 엔터티 간의 연결 또는 상호작용
                                    예) 고객이 주문을 한다, 상품이 주문에 포함된다 등

            스키마 vs 인스턴스
                        = 스키마는 데이터베이스의 구조와 설계를 정의한 것 => 테이블, 열, 데이터 타입, 제약 조건 등을 포함 => 청사진(정적인 개념)
                        = 인스턴스는 스키마에 따라 특정 시점에 저장된 실제 데이터 => 데이터베이스의 동적인 상태
                        Section_identifier Course_number Semester Year Instructor <= 스키마
                        85                 MATH2410      FALL     04   King       <= 인스턴스

데이터 모델 표기법 및 ERD 작성 순서
            1. 데이터 모델 표기법
                        = Peter Chen : 대학에서 가장 많이 이용 / 실무에서 거의 사용하지 않음
                        = IE/Crow's Foot : 까마귀발 모양의 표기법 / 실무에서 가장 많이 사용 / tool) ERWin, ERStudio
                        = IDEF1X(Intergration Definition for Information Modeling) : 마름모와 원을 이용한 표기법으로 실무에서 많이 사용함 / tool) ERWin
                        = Min-Max/ISO : 기수성을 좀 더 정교하게 표현한 방법으로 많이 활용되지 않음
                        = UML : 데이터 모델링과 프로세스 모델링을 동시에 다룸 / tool) Rational Rose
                        = Case Method / Barker's Nation : Crow's Foot과 유사, 관계 표기법 등 일부 다름 / tool) DA#

            2. ERD 작성 순서
                        1. 엔터티를 도출하고 그린다 => 관리해야 할 데이터를 정의하기 위해 엔터티를 식별함 / 학생, 강좌, 교수 등의 엔터티 도출함
                        2. 엔터티를 적절하게 배치한다 => 선이 교차하거나 꼬이지 않도록 배치함 / 왼쪽->오른쪽, 위->아래 순으로 읽을 수 있도록 구성함
                        3. 엔터티 간의 관계를 설정한다 => 식별자 관계를 우선 설정함 / Cycle 관계(순환 관계)가 발생하지 않도록 주의함
                        4. 관계명을 서술한다(양 방향) => 관계명은 현재형으로 작성, 지나치게 포괄적인 단어는 피함 / 실제 프로젝트에서는 관계명 자체를 크게 중요하게 다루지 않는 경우도 있음
                        5. 관계 참여도를 표현한다 => 한 개의 엔터티와 다른 엔터티 간 참여하는 관계 수 를 의미함 / 예) 1:1, 1:N, N:M 관계
                        6. 관계의 필수 여부를 확인한다 => 필수 관계와 선택 관계를 명시함

            3. 좋은 데이터 모델의 요건
                        = 완전성(Completeness) : 업무에서 필요로 하는 모든 데이터가 데이터 모델에 정의되어야 함
                        = 업무규칙(Business Rules) : 업무규칙을 반영하기 위해 필요한 데이터가 데이터 모델에 표현되어야 함
                                                예) '사원에는 정규직, 임시직이 있으며, 정규직만 호봉 정보를 가짐'이라는 업무규칙을 반영하기 위해, 데이터 모델에 '사원 구분', '호봉' 등의 속성이 명시되어야 함
                        = 중복배체(Non-Redundancy) : 동일한 사실은 반드시 한 번만 기록
                        = 데이터 재사용(Data Reusability) : 회사 전체 관점에서 공통 데이터를 도출하고, 이를 전 영역에서 사용할 수 있도록 설계해야 함
                        = 통합성(Integration) : 동일한 데이터는 조직의 전체에서 한 번만 정의되고, 이를 여러 다른 영역에서 참조, 활용해야 함

===========================================================================================================================================================================================================

엔터티 : 업무에 필요한 정보를 저장하고 관리하기 위한 집합적인 것(Thing)
            = Peter Chen(1976) : 변별할 수 있는 사물
            = C.J.Date(1986) : 데이터베이스 내에서 변별 가능한 객체
            = James Martin(1989) : 정보를 저장할 수 있는 어떤 것
            = Thomas Bruce(1992) : 정보가 저장될 수 있는 사람, 장소, 물건, 사건, 개념 등

            = 분류
            1) 물리적 형태의 존재 여부에 따른 분류
                        = 유형 엔터티 : 물리적인 형태가 있고 안정적이며 지속적으로 활용됨 / 예) 교수, 강의실, 학생 등
                        = 개념 엔터티 : 물리적인 형태는 존재하지 않으나 관리해야 할 개념적 정보 / 예) 수업, 보험상품 등
                        = 사건 엔터티 : 업무 수행 과정에서 발생하면 비교적 발생량이 많음(각종 통계 분석의 주요 대상이 됨) / 예) 수강신청, 주문, 입금, 로그인 로그 등
            2) 발생시점 및 상속 관계에 따른 분류
                        = 기본 엔터티 : 다른 엔터티로부터 영향을 받지 않고 독립적으로 생성되며, 스스로 주식별자를 갖는 엔터티 / 예) 직원, 고객, 상품, 부서 등
                        = 중심 엔터티 : 기본 엔터티로부터 주식별자를 상속받아 생성되며, 주로 업무의 핵심적인 데이터를 관리하는 엔터티 / 예) 급여, 주문 등
                        = 행위 엔터티 : 특정 사건이나 활동의 결과로 생성되는 데이터 / 두 개 이상의 엔터티(중심 엔터티 또는 기본 엔터티) 간 관계를 통해 데이터가 생성됨 / 예) 주문 내역, 결제 기록, 수강신청 내역 등
            = 엔터티와 인스턴스
                        = 엔터티 : 데이터베이스에서 관리하고자 하는 객체 => 동일한 성격을 가진 인스턴스의 집합
                        = 인스턴스 : 엔터티를 구성하는 개별 데이터
                        예) '과목' 엔터티 => (데이터베이스 입문, 3학점, 전공필수) / (데이터베이스 실무, 3학점, 전공선택) 등

엔터티의 특징
            1. 엔터티는 해당 업무에서 관리할 필요가 있는 정보를 포함해야 함 => 필요에 따라 결정
            2. 유일한 식별자(PK)에 의하여 식별이 가능해야 함 => 단 하나를 명확하게 식별할 수 있어야 한다
            3. 영속저긍로 존재하는 다수의 인스턴스의 집합이어야 함 => 엔터티는 영속적인 자료 / 둘 이상의 인스턴스 집합 => 하나의 인스턴스 => 존재할 필요가 없다
            4. 업무 프로세스에 의하여 이용되어야 함(CRUD 연산 발생) => 업무 흐름과 밀접하게 연관되어야 함
                        = CRUD 중 최소한 한 가지의 연산에 관여
                        = CRUD 발생X => 업무와 무관한 불필요한 데이터 / 업무 프로세스가 누락
            5. 반드시 속성을 가져야 함 => 속성 : 엔터티가 담고 있는 구체적인 데이터 요소의 최소 단위 => 속성없는 엔터티는 의미가 없다
            6. 주식별자만 존재하고 일반 속성은 없는 경우는 바람직하지 않음 => 업무에서 활용 가치가 없다 / M:N 관계 => 주식별자 속성만으로 구성되는 경우 존재 => 학생:과목 => 학생ID:과목ID
            7. 다른 엔터티와 최소 한 개 이상의 관계를 가져야 함 => 다른 엔터티와 관계를 전혀 맺지 않는 고립 엔터티 => 부적절하게 도출 / 관계 정의가 누락된 상태
                        = 인정 가능 예)
                                    = 통계성 엔터티 : 통계 목적으로 단독 관리되는 엔터티
                                    = 코드성 엔터티 : 참조용 코드 테이블과 같이 별도의 관계 없이 독립적으로 관리하는 엔터티
                                    = 시스템 처리용 내부 엔터티 : 트랜잭션 로그 테이블처럼 시스템 내부 처리 기록을 위해 별도 관리되는 엔터티

엔터티의 명명 원칙
            1. 엔터티 생성 의미대로, 실제 업무에서 사용하는 용어를 사용
            2. 약어를 가급적 사용하지 않는다
            3. 단수 명사 사용
            4. 이름이 동일한 엔터티가 중복으로 존재할 수 없다

===========================================================================================================================================================================================================

관계
            1. 관계와 페어링 : 관계는 두 개 이상의 엔터티 간에 존재하는 논리적 연관성 => 엔터티 내의 각 인스턴스 간의 개별적 연관성이 페어링으로 세분화 가능
                        = 페어링 => 두 개 이상의 인스턴스가 서로 연결된 상태 => 페어링의 집합이 관계를 구성
                        예) 강사 - 강의한다 - 수강생 / 강사1 - 페어링 - 수강생1
            2. 관계의 분류
                        1) 존재에 의한 관계 : 존재 자체로 엔터티 간 연관성이 형성되는 관계 => 사원 ∋ 소속한다 - 부서
                        2) 행위에 의한 관계 : 특정한 업무 수행이나 이벤트 발생을 통해 엔터티 간 연관성이 형성되는 관계 => 주문(사건 엔터티) ∋ 주문한다 - 고객

관계의 표기법
            1. 관계명 : 관계는 두 방향 모두에서 관계명을 가진다
                        예) 부서 (포함한다) -> 사원
                                 <- (소속된다)
                        => 관계명 명명 원칙
                                    = 애매하거나 의미가 모호한 동사('관계된다', '관련있다' 등)는 피한다
                                    = 관계명은 현재형으로 표현하며, 과거 혹은 미래형 표현('~할 것이다', '~했다')을 배제한다.
                                    = 바람직한 관계명: '신청한다', '포함한다', '관리한다' 등
            2. 관계 차수 : 관계를 통해 엔터티 간 참조 가능한 인스턴스 수를 의미한다
                        1) 1:1 관계 => 한 개체가 다른 개체 하나와만 연결되는 경우 => 학생 1- 과대표 -1 학과
                        2) 1:N 관계 => 한 개체가 여러 개체와 연결될 수 있는 경우 => 학생 N- 전공 -1 학과
                        3) M:N 관계 => 하나의 개체가 여러 개체와 연결될 수 있으며, 동시에 다른 개체도 여러 개체와 연결 될 수 있는 관계 => 학생 M- 수강 -N 과목
            3. 관계 선택성 : 관계 참여가 필수인지 여부
                        1) 필수 참여 => 관계 형성 시 한 쪽 엔터티의 인스턴스에 대응되는 인스턴스가 반대편 엔터티에 반드시 존재해야 함 => 부서 |- 포함한다 - 소속된다 ∈ 사원
                        2) 선택 참여 => 관계 형성 시 한 쪽 엔터티의 인스턴스에 대응되는 인스턴스가 반대편 엔터티에 하나도 존재하지 않아도 무방함 => 부서 |- 포함한다 - 소속된다 o∈ 사원
            4. 관계 읽기 : 부서 |- 포함한다 - 소속된다 o∈ 사원 => 사원은 하나의 부서에 반드시 소속 / 부서는 여러 사원을 선택적으로 포함

===========================================================================================================================================================================================================

속성 : 엔터티를 구성하는 가장 기본적인 정보 단위 => 엔터티의 고유한 특징과 성질을 구체화하는데 사용
            1. 정의
                        1) 엔터티의 특징 혹은 본질적 성질 => 엔터티가 무엇인지와 어떤 성격을 지니는지를 명확히 표현하는 요소 => 속성이 없다면 엔터티를 구체화하거나 실체화하기 어려워진다
                        2) 의미상 더 이상 분리되지 않는 최소의 데이터 단위 => 논리적으로 더 쪼갤 수 없는 최소 단위의 정보 => 예) '이름' 속성 (단, '성'과 '이름' => 업무적 필요성에 따라 다른 속성으로 정의하는 행위)
                        3) 엔터티 인스턴스의 성격을 구체화 => 엔터티에 속한 각 인스턴스(개별 데이터 행) 각각에 대해 구체적인 특징을 부여
                        4) 엔터티, 인스턴스, 속성, 속성값 간의 대응 관계
                                    = 엔터티 : 둘 이상의 인스턴스를 가짐
                                    = 인스턴스 : 엔터티를 구성하는 개별 데이터 행 => 각 인스턴스는 다수의 속성을 가짐
                                    = 속성 : 엔터티가 관리해야 할 정보 => 각 속성은 단 하나의 속성값을 가짐
                                    = 속성값 : 각 인스턴스에 대입되는 실제 데이터 값
            2. 특징
                        1) 해당 업무에서 반드시 관리해야 할 의미 있는 정보를 표현해야 한다
                        2) 모든 속성은 엔터티의 주식별자에 함수적으로 종속되어야 한다
                        3) 하나의 속성은 단 하나의 값을 가져야 한다(원자값) => 다중값을 갖는 속성은 별도의 엔터티로 분리하여 관리

속성의 표기
            1. 속성의 명명 원칙
                        1) 속성명은 업무 현장에서 실제로 사용하는 용어를 기반으로 부여
                        2) 약어의 사용은 의미 전달에 혼동 => 지양한다 => 단, 약어가 불가피한 경우 모든 이해관계자가 공감하고 이해할 수 있는 약어 선택
                        3) '~하는' 등의 서술적 표현 대신 명사형을 사용하여 속성명을 간결하고 명확하게 표현
                        4) '~의', '~에 대한' 등의 수식어와 소유격 표현은 피한다
                        5) 가능한 한 전체 데이터 모델 내에서 유일하게 정의한다(권장)
            2. 속성의 표기 : IE 표기법에서는 엔터티를 사각형으로 표현하고, 그 사각형 내부를 가로선으로 구분하는 방식을 사용
                        1) 엔터티 이름(과목, 강사, 사건)은 사각형 바깥쪽에 기술
                        2) 사각형 내부 상다나 부분에는 엔터티의 식별자 속성(과목코드, 강사사번, 사건번호)
                        3) 하단 부분에는 일반 속성(과목명, 과목 설명 등)

                        과목            강사            사건
                    -----------     -----------     -----------
                    | 과목코드 |     | 강사사번 |    | 사건번호 |
                    -----------     ------------    -----------
                    |  과목명  |     |  강사명  |    |  사건명 |
                    | 과목설명 |     | 최종학위 |    | 발생장소 |
                    -----------     -----------     -----------
            3. 속성의 도메인
                        1) 도메인 : 각 속성이 가질 수 있는 값의 범위와 유형을 정의하는 개념 => 속성에 입력될 수 있는 데이터의 타입, 길이, 허용 범위, 제약 사항 등을 규정
                                    => 데이터 무결성을 보장 / 속성값에 대한 일관된 관리와 검증을 가능하게 함 => 예) 평점 속성 : 0.0 <= x <= 4.5 실수형 데이터 / 주소 속성 : 최대 20자 이내의 문자열
                        2) 도메인을 적절히 설정하면 잘못된 값이 입력되는 상황을 사전에 차단 / 데이터베이스 설계와 유지보수에 있어 안정성과 효율성을 높여준다
            4. 속성의 분류
                        1) 속성의 특성에 따른 분류
                                    = 기본 속성 => 업무에서 직접 도출된, 가장 일반적인 속성 => 예) 제품이름 / 제조년월 / 제조원가
                                    = 설계 속성 => 데이터 모델링 과정에서 필요에 의해 새로 정의한 속성 / 주로 코드 형태로 추가, 설계 속성과 기본 속성을 명확히 구분하기는 매우 어려움 => 예) 001-식품용기 / 002-약품용기 => 약품용기코드
                                    = 파생 속성 => 다른 속성들로부터 유도된 속성 / 통계용 데이터나 연산결과가 대표적 / 가능한 최소화 => 예) 전체용기 수 / 용기의 총금액
                        2) 엔터티 구성 방식에 따른 분류
                                    = PK 속성 => 엔터티의 각 인스턴스를 유일하게 식별할 수 있는 속성 / 반드시 존재 / 중복불가
                                    = FK 속성 => 다른 엔터티의 PK를 참조하는 속성 / 엔터티 간 관계를 형성 / 데이터 무결성을 유지하는 데 중요
                                    = 일반 속성 => PK, FK를 제외한 나머지 모든 속성 / 엔터티의 특징과 정보를 나타내는 대부분의 속성
                        3) 분리 가능성에 따른 분류
                                    = 복합 속성 => 하나의 속성이 의미적으로 분해 가능한 하위 속성들로 구성 => 예) '주소'를 '시/도', '구/군', '상세주소'로 나눌 수 있음
                                    = 단순 속성 => 더 이상 분해할 수 없는 원자적 속성 => 예) 성별 / 연령 등
                        4) 속성값의 수에 따른 분류
                                    = 다중값 속성 => 하나의 속성이 여러 값을 동시에 가질 수 있는 경우 / 데이터 정규화 관점에서 별도 엔터티 분리가 권장 => 예) 취미 / 연락처 등
                                    = 단일값 속성 => 하나의 속성이 하나의 값을 갖는 경우 => 예) 생년월일 / 학번 등

===========================================================================================================================================================================================================

식별자 : 데이터 모델링에서 각 엔터티 내의 개별 데이터(인스턴스)를 고유하게 구별할 수 있는 속성 => 데이터의 무결성과 일관성을 유지하는 데 필수 => 기본키
            = 분류)
                        대표성 => 주식별자 - 엔터티 내에서 각 인스턴스를 구분
                                          - 타 엔터티와 참조 관계를 연결할 수 있음(Primary Key)
                               => 보조식별자 - 엔터티 내에서 각 인스턴스를 구분
                                            - 대표성을 갖지 못해 참조 관계 연결에 사용되지 않음(Candidate Key)
                        목적 => 내부식별자 - 엔터티 내부에서 스스로 만들어지는 식별자
                             => 외부식별자 - 관계를 통해 유입되는 타 엔터티의 식별자(Foreign Key)
                                          - 주식별자 속성 또는 일반 속성으로 포함
                        속성 수 => 단일식별자 - 하나의 속성으로 구성된 식별자
                               => 복합식별자 - 둘 이상의 속성으로 구성된 식별자
                        본질 => 본질(원조)식별자 - 업무상 이미 존재하는 속성으로 만들어진 식별자(기본 속성)
                             => 인조(대리)식별자 - 데이터베이스 설계 과정에서 필요에 의해 인위적으로 만들어진 식별자(설계 속성)

            = 특징)
                        유일성 => 주식별자에 의해 엔터티 내의 각 인스턴스들을 모두 유일하게 구분할 수 있어야 함 => 예) 각 회원들에 대해 ID가 개인별로 고유하게 부여됨
                        최소성 => 주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수가 되어야 함 => 예) ID만으로도 유일성이 만족되면, 'ID+이름'의 조합은 주식별자가 아님
                        불변성 => 주식별자가 지정되면, 그 식별자의 값은 변하지 않아야 함 => 예) 회원의 ID의 값은 변하지 않음. => ID의 값이 변한다면, DB 관점에서는 이전의 회원기록은 말소, 새로운 회원이 생성
                        존재성 => 주식별자의 값은 NULL이 될 수 없음 => 예) ID가 없는 회원은 있을 수 없음

주식별자 도출 기준
            1. 업무 활용도가 높은 속성 선택 => 엔터티 내 유일성을 갖춘 속성 중 해당 업무에서 빈번히 조회되고 활용되는 속성을 주식별자로 설정
                        예) 사원번호와 주민번호가 모두 유일성을 갖춘 속성 => 업무에서 사원번호가 더 많이 활용 => 사원번호를 주식별자로 설정 => 주민번호는 보조식별자
            2. 명칭 기반 속성 지양 => 명칭이나 내역 등 문자 정보로 표현되는 속성은 업무 관점에서 자주 변경되거나 중복될 가능성이 높음 => 주식별자로 지정하지 않는 것이 바람직
            3. 복합식별자 구성 시 과도한 속성 포함 방지 => 여러 속성을 결합하여 복합식별자를 구성할 경우, 지나치게 많은 속성을 포함하지 않도록 주의
                        예) 복합식별자(접수일자, 관할부서, 입력자사번 등) => 접수번호와 같은 인조식별자를 새로 생성하여 단순화

식별자 관계와 비식별자 관계 => 부모 엔터티의 주식별자를 자식 엔터티에 어떻게 상속하느냐에 따라
            예) FK가 주식별자에 포함 => 식별자 관계 / FK가 일반 속성으로 포함 => 비식별자 관계
            1. 식별자 관계 => 부모 엔터티의 주식별자 속성을 자식 엔터티가 주식별자로 상속받는 경우 => FK를 PK로 사용
                        1) 부모 엔터티가 생성되지 않으면 자식 엔터티도 존재할 수 없다.
                        2) 자식 엔터티는 주식별자에 부모 엔터티의 식별자(FK)가 반드시 포함되면, 이 속성은 NULL을 허용하지 않는다.
                        3) 관계 차수에 따른 분류 = 자식 엔터티의 주식별자가 부모 식별자만으로 구성 => 1:1 관계
                                                = 자식 엔터티의 주식별자가 부모 식별자 + 추가 속성으로 구성 => 1:N 관계
            2. 비식별자 관계 => 부모 엔터티의 주식별자 속성을 자식 엔터티의 일반 속성으로 포함하는 경우 => FK와 PK가 별도
                        1) 부모 엔터티 없이도 자식 엔터티의 인스턴스 생성이 가능
                        2) 주식별자로 포함할 수도 있지만, 일반 속성으로 두는 것이 더 유리하다면 비식별자 관계를 선택할 수 있다
                                    예) '학생' '수강' => '학생'의 '학번'은 '수강'에서 FK => 자식 엔터티의 주식별자를 '학번' 포함 복합식별자로 생성 => 식별자 관계
                                                                                      => 자식 엔터티에서 '수강번호'라는 인조식별자 생성 => '학번'은 일반 속성 => 비식별자 관계
식별자/비식별자 관계 남용 시 문제
            1. 식별자 관계 남용 시 문제 => 주식별자 속성이 점점 늘어나는 문제 => 예) 학생 => '학교명(FK)', '대학코드(FK)', 학번
            2. 비식별자 관계 남용 시 문제 => 데이터 조회 시 조인 횟수 증가 => 예) select 학생 => 학생-대학코드(FK)-학교명(FK)
            3. 비식별자 관계를 고려해야 하는 경우
                        1) 부모-자식 관계 강도가 약할 때 => 부모 엔터티가 존재하지 않아도 자식 엔터티가 독립적으로 생성되고 운영될 수 있는 경우 => 비식별자 관계로 약한 종속성 표현
                        2) 자식 엔터티가 독립적인 주식별자를 갖는 경우 => 자식 엔터티가 자체적인 주식별자를 갖고 있어서 독립적인 식별이 가능한 상황 => 비식별자 관계로 모델의 단순화, 유연성 확보
                        3) PK 속성의 단순화 필요성 => 식별자 관계 남용 => 복합식별자가 복잡 => 비식별자 관계로 복잡성을 줄이고 PK 구성을 단순화 => 데이터 모델의 관리 효율성과 성능 향상
            4. 식별자 관계와 비식별자 관계 비교
                        구분                        식별자 관계                        비식별자 관계
                        관계 강도            강한 연결관계 표현                        약한 연결관계 표현
                        상속 위치            자식 엔터티의 주식별자에 포함              자식 엔터티의 비식별자 속성에 포함
                        표기법               실선 표현                                점선 표현
                        연결 고려사항        -자식 엔터티가 부모 엔터티에 종속           -자식 주식별자를 독립적으로 구성
                                            -상속받은 주식별자 속성을                  -상속받은 주식별자 속성을
                                            타 엔터티에 전달할 필요가 있는 경우         타 엔터티에 전달하지 않고 차단하고자 하는 경우

===========================================================================================================================================================================================================

본질식별자 vs 인조식별자
            1. 본질식별자 => 엔터티의 고유성을 나타내는 본질적인 속성을 식별자로 사용 => 예) 주민등록번호, 차량번호, 고유코드, ISBN 등
                         => 특징 = 엔터티의 속성에서 도출된 실제 데이터로 구성 / 데이터 해석이 쉽다
                                 = 본질적으로 데이터의 고유성을 보장 / 중복 데이터를 방지
                                 = 본질식별자가 여러 속성으로 구성되거나 데이터 구조가 복잡한 경우, 관리와 인덱싱이 어려울 수 있다
            2. 인조식별자 => 시스템에서 고유성을 보장하기 위해 인위적으로 생성된 값을 식별자로 사용 => 예) 주문번호, 시스템 생성 ID 등
                         => 특징 = 단일 속성으로 구성 / 본질식별자보다 관리가 단순 / 본질식별자가 복잡한 경우 대체
                                 = 인조식별자는 본질적인 고유성을 나타내지 않으므로, 중복 데이터를 방지하거나 데이터의 의미를 유지하기 위해 추가적인 인덱스나 제약 조건이 필요
                                 = 데이터의 본질적 의미를 포함하지 않아, 데이터 해석에 어려움 가능성
                                 = 단순한 관리와 성능 최적화로 개발 편의성을 높일 수 있다 / 모든 상황에서 사용이 바람직한 것은 아니다

===========================================================================================================================================================================================================

예상문제
1. 데이터 모델링은 복잡한 데이터를 이해하기 쉬운 구조로 표현하는 단순화 과정을 포함한다.
2. 데이터베이스 구조를 화면이나 보고서의 요구사항에 따라 자주 변경하면 안정성과 일관성이 훼손될 수 있다.
3. 비일관성 문제, 동일한 데이터가 서로 다른 형태로 저장되거나 해석되어 데이터 신뢰성과 시스템 간 호환에 문제가 발생하는 것
4. 개념적 데이터 모델링은 추상화 수준이 높으면, 업무 중심적인 포괄적인 모델링 방식
5. 개념적 -> 논리적 -> 물리적 데이터 모델링
6. 데이터베이스 3단계 => 외부, 개념, 내부 스키마
7. 외부 스키마는 사용자 관점에서 데이터를 표현하며, 물리적 저장 방식이나 최적화는 내부 스키마에서 다룬다.
8. 논리적 데이터 독립성은 개념 스키마가 변경되더라도 외부 스키마가 영향을 받지 않는 것을 보장한다.
9. IE 표기법에서는 개체 타입에 관계없이 직사각형으로 표시하며, 관계는 다양한 모양의 선과 까마귀 발 등으로 표현한다.
10. 엔터티를 도출하고 그린다 -> 엔터티를 적절하게 배치한다 -> 엔터티 간의 관계를 설정한다 -> 관계명을 서술한다 -> 관계 참여도를 표현한다 -> 관계의 필수 여부를 확인한다
11. 동일한 데이터를 여러 위치에 중복 저장하면 일관성이 떨어지고, 관리 효율성이 저하되기 때문에 바람직하지 않다.
12. 발생시점에 따라 기본, 중심, 행위 엔터티로 분류하고, 유/무형에 따라 유형, 개념, 사건 엔터티로 분류한다.
13. 회원 엔터티 쪽은 점선으로 표시되어 있으므로 주문은 선택사항이다. 따라서 회원은 하나 이상의 주문을 가질 수 있지만, 주문이 없어도 된다.
14. 엔터티는 업무적으로 관리할 필요가 있는 정보를 포함하고, CRUD 연산이 실제로 발생해야 한다.
    엔터티는 반드시 업무적으로 필요하고 관리해야 할 데이터를 포함해야 하며, 불필요한 데이터는 엔터티로 정의되지 않는다.
    일반적으로 엔터티는 주식별자와 함께 속성을 가져야 한다. 다만, 예외적으로 연관 엔터티는 주식별자만으로 구성될 수 있지만 일반적인 경우는 아니다.
    엔터티는 비교적 장기간 유지되는 영속적인 자료를 다룬다.
15. 엔터티는 단수형 명사를 사용해야 한다.
16. "주문 날짜, 주문 번호, 주문된 상품의 정보, 결제 방법 등을 저장하고 추적해야 한다."라는 내용은 업무에서 관리할 필요가 있는 정보를 포함한 주문이 엔터티로 생성될 수 있음을 의미한다.
    주문 날짜는 주문 엔터티의 속성으로 포함될 정보이므로 독립적인 엔터티로 보기 어렵다.
    결제 방법도 주문과 관련된 속성으로 포함될 정보이다.
    상품 정보는 상품이라는 별도의 엔터티로 정의될 수 있지만, 문제에서 엔터티로 관리되는 대상은 주문이므로 속성으로 간주된다.
17. 직원은 시나리오에서 관리해야 할 주요 정보 집합이며, 엔터티로 가장 적합하다.
    회사는 시나리오의 배경이 될 뿐, 시나리오에서 관리 대상이 되는 정보는 아니므로 엔터티로 적합하지 않다.
    부서는 직원 엔터티와 관계를 형성할 수 있는 엔터티로 활용될 가능성이 있지만, 시나리오의 주된 관리 대상은 직원이다.
    연락처는 직원 엔터티의 속성으로, 독립적인 엔터티가 아니라 직원 정보에 포함되어 관리되는 데이터이다.
18. ○ 기호는 선택적 관계를 의미한다. 따라서 하나의 부서에는 사원이 없을 수 있다.
19. 속성은 엔터티를 구성하는 최소 단위의 정보를 의미하며, 엔터티를 구체화하고 실체화하는 데 필수적인 요소이다.
20. 속성명은 가능한 한 전체 데이터 모델 내에서 유일하게 정의되어야 하며, 동일한 이름의 속성이 존재해서는 안 된다. 중복 속성명은 데이터의 혼란을 초래할 수 있다.
21. 도메인은 속성값이 가질 수 있는 범위나 조건을 정의하는 개념이다.
22. 설계 속성은 데이터 모델링 과정에서 필요에 의해 새로 정의한 속성으로, 주로 코드 형태로 추가되며, 설계 속성인지 여부를 명확히 구분하기 어렵다.
23. 파생 속성은 다른 속성들로부터 유도된 속성으로, 다른 속성을 이용해 값을 계산하거나 도출할 수 있다.
24. 하나의 엔터티는 두 개 이상의 인스턴스를 포함하는 데이터 집합을 관리하는 개념이다.
25. 관계 차수란 관계에 참여할 수 있는 엔터티 인스턴스의 수를 의미하며, 일반적으로 1:1, 1:N, M:N 등의 형태가 존재한다.
26. 주식별자 : 엔터티 내부에서 각 인스턴스를 고유하게 식별할 수 있는 대표 속성이다.
    외부식별자 : 다른 엔터티와의 관계를 통해 유입되는 식별자로, 주로 부모 엔터티의 주식별자가 자식 엔터티로 전달되어 참조되는 형태이다.
    인조식별자 : 원래의 주식별자가 복잡하거나 실무에서 다루기 어렵기 때문에, 의도적으로 단순하게 새로 생성한 식별자이다.
27. 부서번호는 사원이 속한 부서를 구분하는 속성이며, 사원을 고유하게 식별할 수 있는 속성이 아니므로 식별자로 적절하지 않다.
28. 주식별자는 한 번 지정되면 데이터 생명주기 동안 변경되지 않아야 한다.
29. 주식별자는 유일성을 만족하는 최소한의 속성으로 구성되어야 한다(최소성). 따라서 '학번'만으로 유일성이 만족된다면, '학번 + 이름'의 조합은 최소성을 만족하지 않으므로 주식별자가 아니다.
30. 자식 엔터티의 주식별자가 부모 엔터티의 주식별자를 상속받아야 하는 경우는 식별자 관계에 해당한다.
31. 본질식별자는 실제 데이터에 기반하여 여러 속성(복합 키)으로 구성될 수 도 있고, 본질적 의미를 포함하기 때문에 중복 방지에도 효과적이다.
