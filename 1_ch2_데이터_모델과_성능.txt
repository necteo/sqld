관계형 데이터베이스
    1. DBMS의 발전 과정 : DBMS => 1960~현재까지 지속적으로 발전하며 데이터 저장 및 관리의 핵심 기술로 자리 잡았다
        1) 1960년대 : 파일 기반 데이터 관리 시대
                    Flowchart를 중심으로 개발 방법을 설계하였으며, 데이터는 주로 파일 구조를 통해 저장하고 관리
                    => 데이터 중복과 일관성 문제 등으로 인해 데이터 관리에 뚜렷한 한계
        2) 1970년대 : DBMS의 초기 등장
                    데이터베이스 관리 기법이 처음으로 등장하면서 본격적인 DBMS 개념이 도입
                    계층형 데이터베이스, 망형 데이터베이스가 상용화 => 데이터의 구조적 관리가 가능
        3) 1980년대 : 관계형 데이터베이스의 상용화
                    관계형 데이터베이스가 상용화되면서 데이터 관리의 새로운 패러다임이 등장
                    데이터를 표(테이블) 형식으로 관리하면, SQL을 기반으로 데이터 처리
                    => Oracle, Sybase, DB2 등
        4) 1990년대 : 관계형 데이터베이스의 확장과 객체 관계형 데이터베이스의 등장
                    RDB가 기장의 주류 => Oracle, Sybase, Informix, DB2, Teradata, SQL Server등 다양한 DBMS 제품 등장
                    객체 지향 프로그래밍의 개념이 통합된 객체 관계형 데이터베이스(ORDB)의 개념이 발전하며 데이터베이스 관리 기술이 더욱 확장

    2. 관계형 데이터베이스 : 관계형 데이터 모델은 데이터를 표(table) 형태로 표현하는 데이터베이스 모델 => 표는 행(row)과 열(column)로 구성, 표들이 서로 관계를 가질 수 있다.
        = 테이블
            => 행과 열의 2차원 구조를 가진 데이터 저장 객체
            => 관계형 데이터베이스의 기본 단위로 릴레이션이라고도 함
        = 칼럼/열
            => 테이블에서 세로 방향으로 이루어진 개별 속성으로, 더 이상 나눌 수 없음
            => 필드라고도 함
        = 로우/행
            => 테이블에서 가로 방향으로 이루어진 연결된 데이터
            => 튜플, 레코드라고도 함

        = 제약 조건
            = 도메인 제약 : 속성에 대한 제약 => 각 속성의 값이 특정 도메인에서 정의된 값이어야 함 => 원자성을 가짐 => 복합 속성, 다중값 속성 (X) / NOT NULL이 아니면 NULL 가능 => 예) '나이'는 정수 => '고려'(X)
            = 키 제약 : 테이블, 즉 릴레이션에 대한 제약 => 릴레이션의 모든 튜플이 서로 고유하게 식별될 수 있도록 보장 => PK가 있어야함
            = 개체 무결성 제약 : 기본 키에 대한 제약 => 기본 키가 반드시 고유한 값을 가지며, NULL 값을 허용하지 않아야 함
            = 참조 무결성 제약 : 외래 키에 대한 제약 => 외래 키의 값은 NULL 값이거나, 해당 외래 키가 참조하는 테이블의 기본 키와 일치해야 함

===========================================================================================================================================================================================================

성능 데이터 모델링
    1. 개념
        = 정의 => 성능 데이터 모델링이란 데이터베이스의 성능을 최적화하기 위해 정규화, 반정규화, 테이블 통합 및 분할, 조인 구조 개선, 기본 키와 외래 키의 적절한 설정 등을 고려하여 데이터 모델링을 수행하는 것을 의미한다
        = 수행시점 => 가능한 빠른 시점에 수행하는 것이 가장 효과적 => 분석 및 설계 단계에서 성능 모델링을 수행하면, 이후 발생할 수 있는 성능 문제를 사전에 예방하고, 재작업으로 인한 비용과 시간을 최소화할 수 있다
                  => 데이터 모델링 설계 후 성능 저하 => 해당 부분만을 SQL 튜닝으로 보완 => 초기 단계부터 성능을 고려한 모델링
    2. 성능 데이터 모델링의 진행 순서
        1) 정규화 수행
            = 데이터 중복 제거와 데이터 무결성 확보를 위해 정규화를 정확히 수행
            = 주요 관심사별로 테이블을 분산시켜 데이터 관리를 체계화함
        2) 데이터베이스 용량 산정
            = 각 엔터티에 저장될 데이터의 양과 크기를 계산함
            = 엔터티별로 처리될 트랜잭션의 양을 파악하여 용량을 예측함
        3) 트랜잭션 유형 분석
            = 데이터베이스에 발생하는 트랜잭션의 유형(CRUD)을 파악함
            = CRUD 매트릭스를 활용해 각 테이블과 트랜잭션 간의관계를 분석함
        4) 반정규화 수행
            = 용량과 트랜잭션 유형을 고려하여 성능을 향상시킬 수 있도록 필요한 부분에 대해 반정규화를 적용함
            = 테이블 병합, 중복 칼럼 추가, 관계 변경 등 반정규화 기법을 사용함
        5) 세부 설계 조정 및 성능 검증
            = 이력 모델의 조정, 인덱스를 고려한 PK/FK의 순서 조정, 슈퍼타입/서브타입 조정 등을 수행함
            = 성능 관점에서 데이터 모델을 최종적으로 검증함

===========================================================================================================================================================================================================

정규화
    1.이상현상
        1) 개념
            => 데이터베이스 설계에서 정규화가 제대로 이루어지지 않았거나 비효율적인 데이터 구조로 인해 발생하는 문제점
            => 이상 현상은 주로 데이터를 삽입, 삭제, 갱신하는 과정에서 비정상적인 결과나 데이터 불일치를 초래한다. => 방지하려면 데이터베이스를 적절히 정규화
        2) 종류
            = 삭제 이상 : 데이터 삭제 시 의도치 않게 다른 관련 데이터까지 손실되는 문제를
                        => 예) '1102' 학생이 'A01' 과목을 수강한 기록을 삭제할 때, 'A01' 과목코드와 함께 '마이닝' 과목명 및 담당 교수인 '강감찬'의 이름도 삭제되는 상황
            = 삽입 이상 : 데이터를 삽입할 때 불필요하거나 불완전한 데이터를 함께 입력해야 하는 비효율적인 상황
                        => 예) '1104, 유관순, 010-4444-5555' 학생 정보를 추가하려 할 떄, 과목코드가 없어서 삽입할 수 없는 상황
            = 갱신 이상 : 데이터 수정 시 동일한 데이터가 여러 곳에 중복 저장되어 있을 경우, 한 곳의 데이터를 수정해도 다른 곳의 데이터와 불일치가 발생하는 문제
                        => 예) '1101' 학생의 연락처를 변경하려 할 때, 홍길동의 연락처가 여러 곳에 기재되어 있다면 이를 모두 수정해야 하는 상황
    2. 정규화
        1) 개념
            => 데이터베이스의 구조를 체계적으로 설계하여 데이터의 중복을 최소화하고, 이상 현상을 방지하며, 데이터 무결성과 효율성을 높이는 것
            => 데이터베이스의 일관성을 유지하고, 저장 공간을 절약하며, 데이터를 삽입, 삭제, 갱신할 때 발생할 수 있는 문제를 예방할 수 있다
        2) 함수적 종속성에 기반
            => 함수는 주어진 x값에 대해 대응하는 y값이 유일하게 결정되는 관계를 의미 => 예) '학번'과 '혈액형'이라는 속성이 있을 때, 특정 혈액형을 기준으로 조회하면 여러 학번이 나옴 => 함수 관계가 아니다
                                                                                       특정 학번을 기준으로 혈액형을 조회하면 항상 하나의 혈액형만 결정 => 학번이 혈액형을 함수적으로 결정한다 => 혈액형은 학번에 함수적으로 종속된다
        3) 종류
            = 제1정규형(1NF) : 모든 속성이 원자값을 가진다
            = 제2정규형(2NF) : 부분 함수 종속을 제거하여 비효율성을 줄인다
            = 제3정규형(3NF) : 이행 함수 종속을 제거하여 데이터 무결성을 유지한다 => 식별자가 아닌 속성이 결정자 역할을 하는 함수 종속을 제거하여 제3정규형을 얻을 수 있다
            = 코드 정규형(BCNF) : 제3정규형을 더욱 강화한 형태로, 모든 함수 종속성의 결정자가 후보 키여야 한다

정규화의 종류
    1. 제1정규형
        1) 개념
            => DB 정규화의 첫 번째 단계 => 테이블의 모든 속성이 원자값을 가져야 함 => 각 칼럼은 더 이상 분리할 수 없는 단일값만 포함해야 하며, 중복된 데이터 구조(반복 그룹)가 없어야 한다
        2) 특징
            = 원자값 : 각 칼럼에는 하나의 값만 저장되며, 값이 리스트나 배열처럼 다중값을 가지면 안 된다
            = 반복 그룹 제거 : 한 행에 같은 종류의 데이터가 반복되지 않아야 한다 => 데이터가 테이블의 칼럼이나 행에서 불필요하게 반복되면 분리해야 한다
    2. 제2정규형
        1) 개념
            => 제1정규형을 만족하면서, 기본 키의 부분 함수 종속을 제거한 상태를 의미한다 => PK가 하나면 제2정규형 만족
        2) 제2정규형 조건
            = 제1정규형 만족 : 모든 속성이 원자값으로 구성되어야 한다 => 즉, 테이블에 중복된 그룹이나 비정규적인 데이터가 없어야 한다
            = 부분 함수 종속 제거 : 기본 키가 복합 키일 때, 기본 키의 일부 속성에만 종속되는 비기본 속성이 없어야 한다
            => 예) 기본 키(A, B)가 있을 때, 비기본 석성 C가 A 또는 B에 종속되면 부분 함수 종속이다 => (학번, 과목코드) => 과목코드 - 과목명 / 학번 - 학생명, 소속학과코드, 학과명 => (학번, 과목코드, 평점)
    3. 제3정규형
        1) 개념
            => 제2정규형을 만족하면서, 이행 함수 종속을 제거한 상태
        2) 제3정규형 조건
            = 제2정규형 만족 : 기본 키의 부분 함수 종속이 없어야 한다
            = 이행 함수 종속 제거 : 비기본 석성이 다른 비기본 속성에 종속되는 경우를 제거해야 한다
            => 예) 기본 키 A가 B를 결정하고, B가 C를 결정한다면, A와 C간의 관계는 이행 함수 종속이다
정규화와 성능
    1. 정규화의 효과
        = 데이터 중복 감소 => 성능 향상
            => 데이터를 중복 없이 체계적으로 관리할 수 있어 저장 공간이 절약되고, 데이터 일관성이 유지된다
        = 데이터가 관심사별로 묶임 => 성능 향상
            => 테이블이 논리적으로 분리되면서 데이터 관리와 유지보수가 쉬워지고, 효율적인 설계가 가능하다
        = 조회 시 조인이 많이 발생 => 성능 저하
            => 테이블이 분리되면서 조회 질의에서 조인이 자주 발생해 성능이 저하될 수 있다
        => 정규화는 일반적으로 성능을 향상시키지만, 조회 작업의 조건에 따라 성능이 향상되거나 저하될 수 있다
        => 데이터베이스 설계 시 정규화와 조회 성능 간의 균형을 고려해야 한다
    2. 정규화를 통한 성능 개선의 예

        1천만건                         4천건        1천만건
        수강                            학생         수강
        (학번, 과목명)    --정규화-->    (학번)-----∈(과목명, 학번FK)
        학색명, 평점, 학년               학생명, 학년  평점
        
        1) 특정 학생의 학년 변경 시
            = 정규화 전 : 해당 학생이 수강 테이블에서 나타나는 수만큼 변경
            = 정규화 후 : 해당 학생의 학년 한 건만 변경
        2) 3학년 학생의 학번, 이름 조회 시
            = 전 : 수강 이력이 누적된 수만큼 인스턴스 조회
            = 후 : 학생 수만큼 인스턴스 조회 => 성능 향상
        3) 학번, 학생명, 과목명, 평점 조회 시
            = 전 : 하나의 테이블에서 모두 조회
            = 후 : 조인 필요 => 약간의 성능 저하

===========================================================================================================================================================================================================

반정규화
    1. 반정규화 => 역정규화 != 비정규화(정규화를 안한것)
        1) 개념
            => 정규화된 데이터베이스의 성능을 향상시키기 위해 중복과 통합, 분리를 수행하는 데이터 모델링 기법
            => 주로 데이터 조회 성능을 개선하거나 시스템의 특정 요구사항을 충족하기 위해 사용
        2) 특징
            = 테이블, 칼럼, 관계의 반정규화 : 반정규화는 테이블 구조, 칼럼의 중복, 테이블 간의 관계를 종합적으로 고려하여 설계된다 => 성능 최적화를 위한 설계 과정의 핵심
            = 속성의 중복 허용 : 데이터 조회 성능을 개선하기 위해 칼럼의 중복 저장을 시도 => 조인 과정을 줄이고, 데이터 접근 속도를 높일 수 있다
            = 과도한 반정규화의 데이터 무결성 침해 : 지나치게 많은 반정규화를 적용하면 데이터 중복이 심해져 데이터 무결성이 침해될 수 있다 => 데이터 변경시 일관성 유지가 어려워지며, 관리 복잡도가 증가한다
    2. 반정규화의 사전 절차
        1) 반정규화 대상 조사            2) 다른 방법 유도 검토        3) 반정규화 적용
            = 범위 처리 빈도수 조사        = 뷰 테이블                    = 테이블 반정규화
            = 대량의 범위 처리 조사        = 클러스터링 적용              = 속성의 반정규화
            = 통계성 프로세스 조사         = 인덱스의 조정                = 관계의 반정규화
            = 테이블 조인 개수             = 응용 애플리케이션

            => 반정규화를 적용하기 전에, 반정규화 대상을 조사하고 데이터베이스 성능을 개선할 수 있는 다른 방법들을 우선적으로 검토해야 한다 => 최후의 수단
                = 뷰 생성 => 뷰는 자체적으로 직접적인 성능 향상을 제공하지는 않지만, 신중하게 설계된 뷰를 재사용함으로써 효율적인 데이터 접근을 가능하게 한다 => 반복적인 조회 작업을 단순화하기 위해 활용될 수 있다
                = 클러스터링 => 자주 함께 사용되는 테이블 데이터를 디스크의 동일한 블록에 저장함으로써 조회 성능을 향상시키는 기법 => 디스크 접근 속도를 줄이고, 관련 데이트를 더 빠르게 로드할 수 있다
                = 인덱스의 조정 => 성능 최적화를 위해 필요한 인덱스를 추가하거나 불필요한 인덱스를 삭제하고, 인덱스의 순서를 조정하는 작업 => 효율적인 인덱스 설계는 검색 속도와 쿼리 성능을 크게 개선 가능
                = 응용 애플리케이션 로직 변경 => 데이터 처리와 관련된 로직을 수정하여 데이터베이스에 대한 의존성을 줄이고 성능을 개선하는 방법 => 애플리케이션 수준에서 최적화가 가능하다면, 반정규화 없이도 성능 문제 해결 가능
        2) 반정규화 기법
            1. 칼럼 반정규화
                = 중복 칼럼 추가 : 조인 횟수를 감소시키기 위해 다른 테이블의 칼럼을 중복으로 저장함
                = 파생 칼럼 추가 : 예상되는 질의에 대한 값을 미리 계산하여 중복으로 저장함
                = 이력 테이블 칼럼 추가 : 이력 데이터 처리의 성능 향상을 위해 종료 여부, 최근값 여부 등의 칼럼을 추가로 저장함
                = PK의 의미적 분리를 위한 칼럼 추가 : PK가 복합 의미를 갖는 경우, 구성 요소 값의 조회 성능 향상을 위해 일반 속성을 추가함
                = 데이터 복구를 위한 칼럼 추가 : 사용자의 실수 또는 응용프로그램 오류로 인해 데이터가 잘못 처리된 경우, 원래 값으로의 복구를 위해 이전 데이터를 중복 저장함
            2. 테이블 반정규화
                = 테이블 병합 => 관계 병합 : 1:1 또는 1:M 관계를 병합함(두 테이블의 동시 조회가 많은 경우)
                             => 슈퍼/서브타입 병합 : 슈퍼/서브타입 관계를 병합함(One To One Type / Single Type / Plus Type) => 슈퍼/서브타입 모델 : 여러 엔터티의 공통 속성과 개별 속성을 체계적으로 관리
                = 테이블 분할 => 수직 분할 : 디스크 I/O의 분산을 위해 테이블을 칼럼 단위로 분리함
                             => 수평 분할 : 디스크 I/O의 분산을 위해 테이블을 로우 단위로 분리함 => 범위 / 리스트 / 해시 파티션
                = 테이블 추가 => 중복 테이블 추가 : 원격 조인(다른 서버 간 조인)을 제거하기 위해 동일한 테이블 구조를 중복시킴
                             => 통계 테이블 추가 : SUM, AVG 등의 통계값을 미리 계산하여 저장함
                             => 이력 테이블 추가 : 이력 테이블 중 일부 레코드를 마스터 테이블에서 중복 관리함
                             => 부분 테이블 추가 : 하나의 테이블에서 집중적으로 이용되는 칼럼들만을 추출하여 별도의 테이블 생성함(테이블 수직 분할과 유사하지만, 원본 테이블을 유지하면서 추가함)
        3) 관계 반정규화 - 중복관계 추가
            => 조인을 통해 정보 조회가 가능하지만 조인 연산이 자주 발생하거나 성능 저하가 우려될 때, 조인 경로를 단축하기 위하여 테이블 간 중복 관계를 추가하는 반정규화 기법
    3. 인덱스 조정
        1) 인덱스의 개념
            => 테이블의 특정 열(칼럼)에 대해 생성된 구조 => 데이터 조회 시 검색 속도를 빠르게 하기 위해 사용
            => 예) 학번이 3000초과 5000미만인 학생을 조회
            => SELECT 학번, 이름, 학년 FROM 학생 WHERE 학번 > 3000 AND 학번 < 5000;
            = 문제점 => 학번이 3000보다 크고 5000보다 작은 학생을 찾기 위해 테이블 전체를 탐색해야 하는 경우가 발생 가능 => RDB에서 데이터가 순서없이 저장되기 때문에 효율적인 검색이 어려운 상황
            = 인덱스 적용 => 학번에 대해 인덱스를 생성하면, 인덱스 테이블이 학번 값을 순서대로 정렬하여 저장 => SQL문 실행 시 테이블 전체를 탐색하지 않고 인덱스 테이블만 탐색하므로 검색 속도가 크게 향상
        2) 인덱스의 특징
            = 장점 : 데이터베이스의 검색 속도를 향상시키는 데 유용한 구조 => 테이블 전체를 탐색하지 않고, 인덱스 테이블만을 탐색하여 필요한 데이터를 빠르게 조회 가능 => Full Scan을 방지
            = 단점 : 지나치게 많은 인덱스를 생성하면 저장 공간이 낭비, 관리 비용 증가 => 인덱스가 적용된 필드의 데이터가 수정되면 인덱스를 갱신 => 삽입 및 갱신 작업의 처리 시간이 증가
            = 생성 방식 PK나 Unique 조건이 설정된 필드에 대해 자동으로 생성 => 특정 필드에 대해 명시적으로 인덱스를 생성하려면 CREATE INDEX 구문 사용

===========================================================================================================================================================================================================

예상문제
1. 외래 키는 NULL 값을 가질 수 있다. 외래 키의 값은 NULL이거나, 해당 외래 키가 참조하는 테이블의 기본 키 값과 일치해야 한다
2. 개채 무결성 제약 조건에서는 기본 키는 중복될 수 없으며, 반드시 고유해야 하고 NULL 값을 허용하지 않는다
3. 나이 속성은 정수값이어야 하지만, 세 번째 행에서 '축구'라는 문자값이 입력되었다. 이는 속성값이 정의된 도메인에서 벗어난 값이므로 도메인 제약 조건에 위배되었다
4. 한 테이블에 하나 이상의 외래 키를 생성할 수 있다 / 외래 키는 NULL 값을 가질 수 있다 / 외래 키는 테이블 생성 시에 설정할 수 있다
5. c->e => ce로 {c,e}가능 / {a,b,d} 포함하지 않음 => ce는 후보키가 아님
   b->cde => ab는 {a,b}+{c,d,e} => ab는 후보키
   d->a => bd는 {a,b,d} , ab->cde => {a,b,d}+{c,b,d} => bd는 후보키
   ad->b => ad로 {a,b,d} , ab->cde => ad로 {a,b,d}+{c,d,e} => ad는 후보키
6. 제1정규형을 만족하면서, 기본 키의 부분 함수 종속을 제거한 상태를 제2정규형이라고 한다
7. 학과코드가 학생번호에 종속되고, 학과명이 학과코드에 종속되므로 이행 함수 종속이 존재한다 => 이행 함수 종속을 제거하지 못했으므로 제3정규형을 위반한 것이다
8. 일반 속성이 학과명이 주식별자 중 학과코드에 종속되어 있는 부분 함수 종속을 제거하였다
   부분 함수 종속을 제거하였으므로, 2차 정규화를 수행한 것이다
   (나)는 부분 함수 종속과 이행 함수 종속이 없으므로 제3정규형을 만족한다
   (가)에서 (나)로의 정규화 후에 조인이 필요하게 되어 약간의 조회 성능이 저하되었다.
9. 기본 키인 {사원번호, 부서코드}가 있을 때, 비기본 속성인 {사원명, 직급, 입사일}은 {사원번호}에만 종속되고, {부서명}은 {부서코드}에만 종속되므로 부분 함수 종속
   => 2차 정규화를 통해 부분 함수 종속을 제거해야 하며, 이에 따라 분리된 스키마는 {사원번호, 사원명, 직급, 입사일}, {부서코드, 부서명}, {사원번호, 부서코드, 근속연수}
10. 제3정규형은 엔터티의 일반 속성 간에는 서로 종속되지 않아야 한다
11. 반정규화는 데이터 중복을 제거하기 위한 방법이 아니라, 성능 최적화를 위해 데이터 중복을 허용하거나 테이블을 병합하는 방식
12. 테이블이 세분화되어 조인 연산이 자주 발생하면 성능 저하가 발생 할 수 있으므로 반정규화를 통해 성능을 개선할 수 있다
    데이터 중복은 정규화 과정을 통해 해결 가능
    복합 속성은 정규화를 통해 단순화 가능
    외래 키 제약 조건은 참조 무결성 설정을 통해 해결 가능
13. 예상되는 질의에 대한 값을 미리 계산하여 중복으로 저장하는 반정규화 기법은 파생 칼럼 추가 기법
    디스크 I/O의 분산을 위해 테이블을 로우 단위로 분리하는 것은 수평 분할
    슈퍼타입은 모든 서브타입이 공통으로 사용하는 속성만을 포함해야 한다 => 각 엔터티(서브타입)에서 고유하게 사용하는 속성은 서브타입에 정의되어야 한다
14. '총주문금액(=수량X단가)'은 기존 데이터를 바탕으로 계산된 값 => 파생 칼럼 추가
15. '최종 근무일', '재직 상태'와 같은 칼럼은 데이터의 이력 관리를 목적으로 추가 => 이력 테이블 칼럼 추가
16. Single 타입은 조인 성능이 우수하여 관리가 편리하다
17. One To One 타입은 슈퍼타입과 서브타입이 각각 개별 테이블로 존재 => 조인이 가장 많이 발생
18. 항상 학부생과 대학원생 정보를 동시에 조회하는 특성 => 하나의 통합 테이블을 만드는 Single 타입이 가장 적절한 방법
19. 인덱스는 조회 성능을 향상시키지만, 인덱스가 많아질 경우 수정 및 삭제 시 인덱스 갱신 작업이 추가되기 때문에 성능이 저하될 수 있다
